
> lint
> eslint games js --ext .js,.mjs,.cjs,.ts --format=json

[{"filePath":"/app/games/breakout/breakout.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/games/breakout/breakout.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"(() => {\n  'use strict';\n\n  /***********************\n   *  Score submit hook  *\n   ***********************/\n  let submitOnce = false;\n  async function submitBreakoutScore(finalScore) {\n    if (submitOnce) return;\n    submitOnce = true;\n    try {\n      if (typeof window.submitScore === 'function') {\n        await window.submitScore('breakout', Number(finalScore) || 0);\n      }\n    } catch (_) {\n      // allow retry if it fails (e.g., network hiccup)\n      submitOnce = false;\n    }\n  }\n\n  /****************************\n   *  DOM helpers & elements  *\n   ****************************/\n  const $ = (id) => document.getElementById(id);\n\n  const canvas   = $('c');\n  const ctx      = canvas.getContext('2d');\n\n  const scoreEl  = $('score');\n  const livesEl  = $('lives');\n  const levelEl  = $('level');\n  const bestEl   = $('best');\n\n  const startBtn = $('startBtn');\n  const resetBtn = $('resetBtn');\n  const muteBtn  = $('muteBtn');\n  const fsBtn    = $('fsBtn');\n  const quitBtn  = $('quitBtn');\n  const brandLink= $('brandLink');\n\n  const gameWrap = $('gameWrap');\n\n  // Optional panels if present in your HTML\n  const localHSList = $('localHighscores');\n  const leaderboardBox = $('leaderboard');\n\n  /****************\n   *  UI helpers  *\n   ****************/\n  function escapeHtml(s){\n    return String(s).replace(/[&<>\"']/g, m => (\n      {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[m]\n    ));\n  }\n\n  async function loadLeaderboard(){\n    if (!leaderboardBox) return;\n    leaderboardBox.innerHTML = '<em>Loadingâ€¦</em>';\n    try {\n      const r = await fetch('/api/scores?game=breakout&limit=25', { cache: 'no-store' });\n      const data = await r.json();\n      leaderboardBox.innerHTML = (Array.isArray(data) && data.length)\n        ? '<ol style=\"margin:0 0 0 1.25rem;line-height:1.8\">' +\n            data.map((s,i)=>`<li><strong>#${i+1}</strong> â€” ${escapeHtml(s.player)} â€” <strong>${Number(s.score).toLocaleString()}</strong></li>`).join('') +\n          '</ol>'\n        : '<p>No scores yet â€” be the first!</p>';\n    } catch {\n      leaderboardBox.innerHTML = '<p>Could not load scores.</p>';\n    }\n  }\n\n  /*****************\n   *  Audio setup  *\n   *****************/\n  let audioCtx = null;\n  let muted = (localStorage.getItem('breakout_muted') === '1');\n\n  function ensureAudio(){\n    if (!audioCtx) {\n      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }\n      catch { return; }\n    }\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume();\n    }\n  }\n\n  function tone(freq=440, dur=0.08, type='sine', vol=0.05){\n    if (muted || !audioCtx) return;\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = type;\n    o.frequency.value = freq;\n    g.gain.value = vol;\n    o.connect(g); g.connect(audioCtx.destination);\n    const now = audioCtx.currentTime;\n    o.start(now);\n    o.stop(now + dur);\n    g.gain.setValueAtTime(vol, now);\n    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);\n  }\n  const sPaddle = () => tone(420, 0.06, 'sine', 0.06);\n  const sBrick  = () => tone(660, 0.05, 'triangle', 0.05);\n  const sBeep   = (i) => {\n    if (i === 3) tone(360, 0.10, 'square', 0.06);\n    else if (i === 2) tone(520, 0.10, 'square', 0.06);\n    else if (i === 1) tone(760, 0.12, 'square', 0.07);\n    else if (i === 0) tone(980, 0.14, 'sawtooth', 0.07);\n  };\n\n  /******************\n   *  Game state    *\n   ******************/\n  const W = canvas.width;\n  const H = canvas.height;\n\n  let running = false;\n  let paused  = false;\n\n  let score = 0;\n  let lives = 3;\n  let level = 1;\n\n  // countdown before each serve\n  let controlsLocked   = true;\n  let countdown        = 3;\n  let countdownFrames  = 0;\n  const PULSE_FRAMES   = 60;\n  const PULSE_COLORS   = ['#ef4444','#f59e0b','#22c55e'];\n\n  // paddle / ball / bricks\n  const paddle = { w: 160, h: 16, x: (W-160)/2, y: H-36, speed: 7 };\n  const ball   = { x: W/2, y: H-80, r: 8, vx: 0, vy: 0 };\n\n  let cols  = 14;\n  let rows  = 4;\n  let brickW= (W - 80) / cols;\n  let brickH= 22;\n  let bricks= [];\n  const margin = 50;\n\n  // difficulty knobs\n  let MAX_SPEED     = 4.2;\n  let SPEED_UP_HIT  = 0.015;\n  let EDGE_MULT     = 3.0;\n\n  // popups\n  const popups = [];\n  let bonusToast = null;\n\n  // input\n  const keys = new Set();\n\n  /*************************\n   *  Local high-scores    *\n   *************************/\n  function getHS(){\n    try { const a = JSON.parse(localStorage.getItem('breakout_highscores_v2') || '[]'); return Array.isArray(a) ? a : []; }\n    catch { return []; }\n  }\n  function saveHS(arr){ localStorage.setItem('breakout_highscores_v2', JSON.stringify(arr)); }\n  function isTop10(sc){ const a = getHS(); return a.length < 10 || sc > a[a.length-1].s; }\n  function pushHS(sc, name){\n    let a = getHS();\n    a.push({ n: (name || '???').toUpperCase().slice(0,3), s: Number(sc)||0 });\n    a = a.filter(o => Number.isFinite(o.s) && typeof o.n === 'string');\n    a.sort((x,y)=>y.s-x.s);\n    a = a.slice(0,10);\n    saveHS(a); return a;\n  }\n  function renderLocalHS(){\n    if (!localHSList) return;\n    try {\n      const a = getHS();\n      localHSList.innerHTML = a.length\n        ? a.map((o,i)=>`<li>#${i+1} â€” ${escapeHtml(o.n)} â€” ${o.s.toLocaleString()}</li>`).join('')\n        : '<li>No scores yet</li>';\n    } catch {\n      localHSList.innerHTML = '<li>No scores yet</li>';\n    }\n  }\n\n  // best\n  function updateBest(newScore){\n    const prev = Number(localStorage.getItem('breakout_best') || 0);\n    const next = Math.max(prev, Number(newScore)||0);\n    localStorage.setItem('breakout_best', next);\n    if (bestEl) bestEl.textContent = next;\n    return next;\n  }\n  // init best label\n  updateBest(0);\n\n  /*******************\n   *  Level setup    *\n   *******************/\n  function settingsForLevel(l){\n    if (l <= 1) return { paddleW: 180, rows: 4, init: 1.6, max: 4.2, hit: 0.015, edge: 3.0 };\n    if (l === 2) return { paddleW: 160, rows: 5, init: 1.8, max: 4.6, hit: 0.02,  edge: 3.2 };\n    const g = Math.min(l-2, 5);\n    return {\n      paddleW: Math.max(140 - g*6, 120),\n      rows   : Math.min(4 + l, 8),\n      init   : Math.min(1.8 + g*0.15, 3.0),\n      max    : Math.min(4.6 + g*0.25, 6.0),\n      hit    : Math.min(0.02 + g*0.005, 0.04),\n      edge   : Math.min(3.0 + g*0.2, 4.0)\n    };\n  }\n\n  let launchSpeed = 0;\n  let launchDir   = 1;\n\n  function applyLevel(){\n    const s = settingsForLevel(level);\n    paddle.w = s.paddleW; paddle.x = (W - paddle.w) / 2;\n    rows = s.rows; brickW = (W - 80) / cols;\n    MAX_SPEED   = s.max; SPEED_UP_HIT = s.hit; EDGE_MULT = s.edge;\n\n    // bricks\n    bricks = [];\n    for (let r=0; r<rows; r++){\n      for (let c=0; c<cols; c++){\n        const x = 40 + c*brickW, y = margin + r*(brickH+8);\n        const rank = (rows - r);\n        bricks.push({ x, y, w: brickW - 6, h: brickH, alive: true, val: rank*10, rank });\n      }\n    }\n\n    // ball\n    ball.x = W/2; ball.y = H-80; ball.vx = 0; ball.vy = 0;\n    launchDir = (Math.random() > 0.5 ? 1 : -1);\n    launchSpeed = s.init;\n\n    controlsLocked  = true;\n    countdown       = 3;\n    countdownFrames = 0;\n    sBeep(3);\n\n    if (levelEl) levelEl.textContent = level;\n    if (scoreEl) scoreEl.textContent = String(score);\n    if (livesEl) livesEl.textContent = String(lives);\n  }\n\n  function nextLevel(){\n    const bonus = level * 200;\n    score += bonus;\n    if (scoreEl) scoreEl.textContent = String(score);\n    bonusToast = { text: `BONUS +${bonus}`, life: 90 };\n    level++;\n    applyLevel();\n  }\n\n  /*****************\n   *  Rendering    *\n   *****************/\n  function roundRect(x,y,w,h,r,fill){\n    ctx.beginPath();\n    ctx.moveTo(x+r,y);\n    ctx.arcTo(x+w,y, x+w,y+h, r);\n    ctx.arcTo(x+w,y+h, x,y+h, r);\n    ctx.arcTo(x,y+h, x,y, r);\n    ctx.arcTo(x,y, x+w,y, r);\n    if (fill) ctx.fill();\n  }\n\n  function brickColor(rank){\n    const t = rank / Math.max(1, rows);\n    const g = Math.floor(160 + 80 * t);\n    const bl= Math.floor(200 - 60 * t);\n    return `rgb(30, ${g}, ${bl})`;\n  }\n\n  function render(){\n    // bg\n    ctx.fillStyle = '#02060d'; ctx.fillRect(0,0,W,H);\n    for (let i=0;i<60;i++){\n      ctx.fillStyle = 'rgba(124,231,162,.07)';\n      const x = (i * 157) % W, y = (i * 73) % H;\n      ctx.fillRect(x,y,2,2);\n    }\n\n    // paddle\n    ctx.fillStyle = '#12d68d'; roundRect(paddle.x, paddle.y, paddle.w, paddle.h, 8, true);\n\n    // ball\n    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);\n    ctx.fillStyle = '#7ce7a2'; ctx.fill();\n\n    // bricks\n    for (const b of bricks){\n      if (!b.alive) continue;\n      ctx.fillStyle = brickColor(b.rank);\n      roundRect(b.x, b.y, b.w, b.h, 6, true);\n    }\n\n    // popups\n    for (let i=popups.length-1; i>=0; i--){\n      const p = popups[i];\n      const t = p.life / 70;\n      ctx.globalAlpha = Math.max(0, t);\n      ctx.fillStyle = '#e6edf3';\n      ctx.font = (14 + (1-t)*6) + 'px Inter';\n      ctx.textAlign = 'center';\n      ctx.fillText(p.text, p.x, p.y);\n      ctx.globalAlpha = 1;\n      p.y -= 1.2;\n      p.life -= 1;\n      if (p.life <= 0) popups.splice(i,1);\n    }\n\n    // bonus toast\n    if (bonusToast){\n      const t = bonusToast.life / 90;\n      ctx.globalAlpha = Math.max(0, t);\n      ctx.fillStyle = '#7ce7a2';\n      ctx.font = (28 + (1-t)*10) + 'px Inter';\n      ctx.textAlign = 'center';\n      ctx.fillText(bonusToast.text, W/2, H*0.35);\n      ctx.globalAlpha = 1;\n      bonusToast.life -= 1;\n      if (bonusToast.life <= 0) bonusToast = null;\n    }\n\n    // pause overlay\n    if (paused){\n      ctx.fillStyle = 'rgba(0,0,0,.45)'; ctx.fillRect(0,0,W,H);\n      ctx.fillStyle = '#e6edf3'; ctx.font = '24px Inter'; ctx.textAlign = 'center';\n      ctx.fillText('Paused â€” Space resume â€¢ R restart â€¢ Enter start', W/2, H/2);\n    }\n\n    // countdown overlay\n    if (countdown > 0){\n      ctx.fillStyle = 'rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);\n      const stageIndex = Math.max(0, 3 - countdown); // 0/1/2\n      const color = PULSE_COLORS[stageIndex];\n      const t = countdownFrames / PULSE_FRAMES; // 0..1\n      const maxR = Math.min(W,H) * 0.35;\n      const r = maxR * t;\n      ctx.beginPath(); ctx.arc(W/2, H/2, r, 0, Math.PI*2);\n      ctx.strokeStyle = color; ctx.globalAlpha = 0.25 * (1-t);\n      ctx.lineWidth = 8 * (1-t); ctx.stroke(); ctx.globalAlpha = 1;\n      ctx.fillStyle = color; ctx.font = (34*(1+0.3*(1-t))) + 'px Inter'; ctx.textAlign = 'center';\n      ctx.fillText(`Level ${level}`, W/2, H/2 + (8*(1-t)));\n    }\n  }\n\n  /****************\n   *  Game loop   *\n   ****************/\n  function clampSpeed(){\n    const s = Math.hypot(ball.vx, ball.vy);\n    if (s > MAX_SPEED){\n      const k = MAX_SPEED / s;\n      ball.vx *= k; ball.vy *= k;\n    }\n  }\n\n  function update(){\n    // paddle\n    if (!controlsLocked){\n      if (keys.has('ArrowLeft'))  paddle.x -= paddle.speed;\n      if (keys.has('ArrowRight')) paddle.x += paddle.speed;\n    }\n    paddle.x = Math.max(10, Math.min(W - paddle.w - 10, paddle.x));\n\n    // countdown\n    if (countdown > 0){\n      countdownFrames++;\n      if (countdownFrames >= PULSE_FRAMES){\n        countdown--; countdownFrames = 0;\n        if (countdown > 0) sBeep(countdown);\n        if (countdown === 0){\n          sBeep(0);\n          ball.vx = launchSpeed * (launchDir || 1);\n          ball.vy = -launchSpeed;\n          controlsLocked = false;\n        }\n      }\n      return;\n    }\n\n    // move ball\n    ball.x += ball.vx; ball.y += ball.vy;\n\n    // walls\n    if (ball.x < ball.r || ball.x > W - ball.r) ball.vx *= -1;\n    if (ball.y < ball.r) ball.vy *= -1;\n\n    // paddle collision\n    if (ball.y + ball.r >= paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w && ball.vy > 0){\n      const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);\n      ball.vx = hit * EDGE_MULT;\n      ball.vy = -Math.max(Math.abs(ball.vy), 1.5);\n      sPaddle();\n      ball.y = paddle.y - ball.r - 1;\n      clampSpeed();\n    }\n\n    // bricks\n    for (const b of bricks){\n      if (!b.alive) continue;\n      if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h){\n        b.alive = false;\n        const gained = b.val;\n        score += gained;\n        if (scoreEl) scoreEl.textContent = String(score);\n        popups.push({ x: b.x + b.w/2, y: b.y + b.h/2, text: `+${gained}`, life: 70 });\n        sBrick();\n        ball.vy *= -1;\n        break;\n      }\n    }\n\n    // cleared?\n    if (bricks.every(b => !b.alive)) { nextLevel(); }\n\n    // fell off?\n    if (ball.y - ball.r > H){\n      lives--;\n      if (livesEl) livesEl.textContent = String(lives);\n      if (lives <= 0){\n        endRun(false);\n      } else {\n        // re-serve\n        controlsLocked  = true;\n        countdown       = 3;\n        countdownFrames = 0;\n        ball.x = W/2; ball.y = H-80; ball.vx = 0; ball.vy = 0;\n        sBeep(3);\n      }\n    }\n  }\n\n  function loop(){\n    if (!running) return;\n    if (!paused) update();\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  /*****************\n   *  End-of-run   *\n   *****************/\n  let enteringInitials = false;\n  let initials = '';\n  let pendingScore = 0;\n\n  function endRun(/* won */){\n    paused = true;\n    running = true; // keep draw loop for overlay\n    updateBest(score);\n\n    // fire-and-forget cloud submit (guarded)\n    submitBreakoutScore(score);\n\n    if (isTop10(score)){\n      enteringInitials = true;\n      initials = '';\n      pendingScore = score;\n      controlsLocked = true;\n    } else {\n      renderLocalHS();\n      loadLeaderboard();\n    }\n  }\n\n  function finishInitials(){\n    enteringInitials = false;\n    const name = (initials && initials.trim()) ? initials : '???';\n    localStorage.setItem('player_name', name);\n    pushHS(pendingScore, name);\n    renderLocalHS();\n    // Already posted above via submitBreakoutScore(score)\n    loadLeaderboard();\n  }\n\n  // expose a simple hook (for external calls if needed)\n  window.breakoutHooks = {\n    endRun: (finalScore) => {\n      // optional external trigger; if score passed, override\n      if (typeof finalScore === 'number') score = finalScore;\n      endRun(false);\n    }\n  };\n\n  /*****************\n   *  Input bind   *\n   *****************/\n  window.addEventListener('keydown', (e) => {\n    // initials entry\n    if (enteringInitials){\n      if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)){\n        if (initials.length < 3) initials += e.key.toUpperCase();\n        e.preventDefault(); return;\n      }\n      if (e.key === 'Backspace'){ initials = initials.slice(0,-1); e.preventDefault(); return; }\n      if (e.key === 'Enter'){ finishInitials(); e.preventDefault(); return; }\n      if (e.key === 'Escape'){ initials = ''; finishInitials(); e.preventDefault(); return; }\n      e.preventDefault(); return;\n    }\n\n    // normal controls\n    if (['ArrowLeft','ArrowRight',' ','Enter','r','R','m','M','f','F','Escape'].includes(e.key)) e.preventDefault();\n\n    if ([' ','Enter','r','R','m','M','f','F'].includes(e.key)) ensureAudio();\n\n    if (e.key === 'f' || e.key === 'F') { toggleFs(); return; }\n    if (e.key === 'Escape') { paused = !paused; updatePauseUI(); return; }\n\n    keys.add(e.key);\n\n    if (e.key === ' ') {\n      if (!running) { running = true; loop(); }\n      else { paused = !paused; updatePauseUI(); }\n    }\n    if (e.key === 'Enter'){\n      if (!running) { running = true; loop(); }\n      paused = false; updatePauseUI();\n    }\n    if (e.key === 'r' || e.key === 'R'){\n      // reset same level\n      applyLevel();\n      paused = false; updatePauseUI();\n      if (!running) { running = true; loop(); }\n    }\n    if (e.key === 'm' || e.key === 'M'){\n      setMute(!muted);\n    }\n  });\n\n  window.addEventListener('keyup', (e) => keys.delete(e.key));\n\n  // Touch to unlock audio\n  canvas.addEventListener('pointerdown', () => { ensureAudio(); }, { passive: true });\n\n  /*****************\n   *  Fullscreen   *\n   *****************/\n  function isFs(){ return document.fullscreenElement || document.webkitFullscreenElement; }\n  function updateFsBtn(){ if (fsBtn) fsBtn.textContent = isFs() ? 'ðŸ—— Windowed' : 'â›¶ Fullscreen'; }\n  async function enterFs(){\n    try {\n      if (gameWrap.requestFullscreen) await gameWrap.requestFullscreen();\n      else if (gameWrap.webkitRequestFullscreen) await gameWrap.webkitRequestFullscreen();\n    } catch {}\n    updateFsBtn();\n  }\n  async function exitFs(){\n    try {\n      if (document.exitFullscreen) await document.exitFullscreen();\n      else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();\n    } catch {}\n    updateFsBtn();\n  }\n  function toggleFs(){ ensureAudio(); if (isFs()) exitFs(); else enterFs(); }\n  if (fsBtn) fsBtn.addEventListener('click', toggleFs);\n  document.addEventListener('fullscreenchange', updateFsBtn);\n  document.addEventListener('webkitfullscreenchange', updateFsBtn);\n\n  // Nav buttons\n  if (startBtn) startBtn.addEventListener('click', () => {\n    ensureAudio();\n    if (!running) { running = true; loop(); }\n    else { paused = !paused; }\n    updatePauseUI();\n  });\n  if (resetBtn) resetBtn.addEventListener('click', () => {\n    ensureAudio();\n    applyLevel();\n    paused = false;\n    updatePauseUI();\n  });\n  if (muteBtn) muteBtn.addEventListener('click', () => {\n    ensureAudio();\n    setMute(!muted);\n  });\n  if (quitBtn) quitBtn.addEventListener('click', () => {\n    running = false;\n    window.location.assign('../../');\n  });\n  if (brandLink) brandLink.addEventListener('click', (e) => {\n    e.preventDefault();\n    window.location.assign('../../');\n  });\n\n  function setMute(m){\n    muted = m;\n    localStorage.setItem('breakout_muted', m ? '1' : '0');\n    if (muteBtn) muteBtn.textContent = m ? 'ðŸ”‡ Sound Off' : 'ðŸ”Š Sound On';\n  }\n\n  function updatePauseUI(){\n    if (quitBtn) quitBtn.style.display = paused ? 'inline-block' : 'none';\n  }\n\n  /**************\n   *  Boot      *\n   **************/\n  function start(){\n    // labels\n    if (scoreEl) scoreEl.textContent = String(score);\n    if (livesEl) livesEl.textContent = String(lives);\n    if (levelEl) levelEl.textContent = String(level);\n\n    renderLocalHS();\n    loadLeaderboard();\n    applyLevel();\n    render(); // first frame\n  }\n\n  start();\n})();\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"/app/games/highway-hopper/lilypads.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/games/highway-hopper/lilypads.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Lily pads module\nexport const PAD_COLS = [2, 4, 6, 8, 10]; // ends pulled inward for balance\n\n// occupiedCols is an optional Set<number> of columns that already have frogs\nexport function drawLilyPads(ctx, tileToPx, tileW, tileH, row, waterColor, occupiedCols = new Set()){\n  const rx = tileW * 0.44;\n  const ry = tileH * 0.34;\n\n  for (const col of PAD_COLS){\n    const [x, y] = tileToPx(col, row);\n    const cx = x + tileW/2;\n    const cy = y + tileH/2;\n\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,.35)';\n    ctx.beginPath();\n    ctx.ellipse(cx, cy + tileH*0.22, rx*0.7, ry*0.35, 0, 0, Math.PI*2);\n    ctx.fill();\n\n    // pad\n    ctx.fillStyle = '#2aa66a';\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);\n    ctx.fill();\n\n    // notch\n    ctx.fillStyle = waterColor || '#133a68';\n    ctx.beginPath();\n    ctx.moveTo(cx, cy);\n    ctx.arc(cx, cy, rx * 0.55, -0.35, 0.35);\n    ctx.closePath();\n    ctx.fill();\n\n    // occupied frog marker\n    if (occupiedCols.has(col)){\n      const w = tileW * 0.55, h = tileH * 0.45;\n      ctx.save();\n      ctx.translate(cx - w/2, cy - h/2);\n      ctx.fillStyle = '#1d7d52';\n      roundRect(ctx, 0, 0, w, h, 10);\n      ctx.fill();\n      ctx.fillStyle = '#0a0e14';\n      ctx.beginPath(); ctx.arc(w*0.30, h*0.25, 3, 0, Math.PI*2); ctx.fill();\n      ctx.beginPath(); ctx.arc(w*0.70, h*0.25, 3, 0, Math.PI*2); ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  function roundRect(ctx,x,y,w,h,r=8){\n    ctx.beginPath();\n    ctx.moveTo(x+r,y);\n    ctx.arcTo(x+w,y,x+w,y+h,r);\n    ctx.arcTo(x+w,y+h,x,y+h,r);\n    ctx.arcTo(x,y+h,x,y,r);\n    ctx.arcTo(x,y,x+w,y,r);\n    ctx.closePath();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"/app/games/highway-hopper/traffic.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/games/highway-hopper/traffic.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Traffic system module\nexport function createTrafficSystem({ tileW, tileH, offsetX, boardW, rows }){\n  const vehicles = []; // { x, row, lenTiles, dir, speed, color }\n  let lanes = [];\n  const laneTimers = new Map();\n\n  function configure({ lanes: laneDefs }){\n    lanes = laneDefs.slice();\n    laneTimers.clear();\n    lanes.forEach(l => laneTimers.set(l.row, 0));\n  }\n\n  function update(dt){\n    // move\n    for (let i = vehicles.length - 1; i >= 0; i--){\n      const v = vehicles[i];\n      v.x += v.dir * v.speed * dt;\n      if ((v.dir === 1 && v.x > offsetX + boardW + tileW*2) ||\n          (v.dir === -1 && v.x < offsetX - tileW*2)){\n        vehicles.splice(i, 1);\n      }\n    }\n\n    // spawn\n    for (const cfg of lanes){\n      const t = (laneTimers.get(cfg.row) || 0) + dt * 1000; // ms\n      const laneCount = vehicles.reduce((n, v) => n + (v.row === cfg.row ? 1 : 0), 0);\n      const target = cfg.interval + Math.random() * (cfg.jitter || 0);\n      if (t >= target && laneCount < (cfg.maxEntities || 3)){\n        laneTimers.set(cfg.row, 0);\n        const len = cfg.lengths[Math.floor(Math.random() * cfg.lengths.length)];\n        const startX = cfg.dir === 1 ? (offsetX - len*tileW - tileW) : (offsetX + boardW + tileW);\n        const color = cfg.color || '#ffbd6b'; // safe default, no external colors array needed\n        vehicles.push({ x: startX, row: cfg.row, lenTiles: len, dir: cfg.dir, speed: cfg.speed, color });\n      } else {\n        laneTimers.set(cfg.row, t);\n      }\n    }\n  }\n\n  function draw(ctx){\n    for (const v of vehicles){\n      const w = v.lenTiles * tileW * 0.95;\n      const h = tileH * 0.7;\n      const vx = v.x + (tileW * 0.025);\n      const vy = (v.row * tileH) + ((tileH - h) / 2);\n      ctx.save();\n      ctx.fillStyle = v.color;\n      roundRect(ctx, vx, vy, w, h, 10);\n      ctx.fill();\n      ctx.fillStyle = '#1a1a1a';\n      ctx.fillRect(vx + 6, vy + h - 6, 14, 4);\n      ctx.fillRect(vx + w - 20, vy + h - 6, 14, 4);\n      ctx.restore();\n    }\n  }\n\n  function overlaps(row, playerCol){\n    for (const v of vehicles){\n      if (v.row !== row) continue;\n      const startCol = Math.floor((v.x - offsetX) / tileW);\n      const endCol   = Math.floor(((v.x + v.lenTiles * tileW - 1) - offsetX) / tileW);\n      if (playerCol >= startCol && playerCol <= endCol){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // local helper (module private)\n  function roundRect(ctx, x, y, w, h, r = 8){\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  return { configure, update, draw, overlaps };\n}","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"/app/games/highway-hopper/water.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/games/highway-hopper/water.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Water system: logs + turtles + crocs; water is hazardous unless on a floating platform.\nexport function createWaterSystem({ tileW, tileH, offsetX, boardW, rows }){\n  // platform:\n  // { x,row,lenTiles,dir,speed,type,phase?,submerge?,blink?,hasPassenger?, _geom? }\n  const platforms = [];\n  let lanes = [];\n  const laneTimers = new Map();\n  let passengerActive = false; // only one on river at a time\n\n  // ---------- Public API ----------\n  function configure({ lanes: laneDefs }){\n    lanes = laneDefs.slice();\n    laneTimers.clear();\n    lanes.forEach(l => laneTimers.set(l.row, 0));\n\n    // reset runtime state on reconfigure (e.g., level up)\n    passengerActive = false;\n    platforms.length = 0;\n  }\n\n  function update(dt){\n    // Move & lifecycle\n    for (let i = platforms.length - 1; i >= 0; i--){\n      const p = platforms[i];\n      p.x += p.dir * p.speed * dt;\n\n      // turtles & crocs: submerge cycle + blink timer for warning flash\n      if ((p.type === 'turtle' || p.type === 'croc') && p.submerge){\n        p.phase = (p.phase + dt) % p.submerge.period;\n        p.blink = (p.blink || 0) + dt;\n      }\n\n      // Despawn when far off-screen\n      if ((p.dir === 1 && p.x > offsetX + boardW + tileW*2) ||\n          (p.dir === -1 && p.x < offsetX - tileW*2)){\n        if (p.hasPassenger) passengerActive = false;\n        platforms.splice(i,1);\n      }\n    }\n\n    // Spawns\n    for (const cfg of lanes){\n      const t = (laneTimers.get(cfg.row) || 0) + dt * 1000;\n      const laneCount = platforms.reduce((n,p)=> n + (p.row===cfg.row ? 1 : 0), 0);\n      const target = cfg.interval + Math.random()*(cfg.jitter||0);\n\n      if (t >= target && laneCount < (cfg.maxEntities||3)){\n        const len = pick(cfg.lenTiles||[2]);\n\n        // NEW: spacing so platforms don't glue head-to-tail\n        const minGapTiles = cfg.minGapTiles ?? 1;\n        if (!canSpawnInLane(cfg.row, cfg.dir, len, minGapTiles)){\n          laneTimers.set(cfg.row, t - 200); // retry soon\n          continue;\n        }\n\n        laneTimers.set(cfg.row, 0);\n\n        const startX = cfg.dir === 1\n          ? (offsetX - len*tileW - tileW)\n          : (offsetX + boardW + tileW);\n\n        const plat = {\n          x:startX, row:cfg.row, lenTiles:len,\n          dir:cfg.dir, speed:cfg.speed, type:cfg.type\n        };\n\n        // Submerge model for turtles/crocs\n        if ((cfg.type==='turtle' || cfg.type==='croc') && cfg.submerge){\n          const base = cfg.submerge; // {period, down, warn?}\n          // vary uptime slightly; same down time\n          const useLong = Math.random() < 0.5;\n          const extra = 3 + Math.random()*3;\n          const period = useLong ? (base.period + extra) : base.period;\n          const down   = base.down;\n          const warn   = base.warn ?? 2;\n          plat.submerge = { period, down, warn };\n          plat.phase = 0;\n          plat.blink = 0;\n        }\n\n        // Passenger spawns only on logs/turtles\n        if (!passengerActive && (cfg.type === 'log' || cfg.type === 'turtle') && Math.random() < 0.15){\n          plat.hasPassenger = true;\n          passengerActive = true;\n        }\n\n        platforms.push(plat);\n      } else {\n        laneTimers.set(cfg.row, t);\n      }\n    }\n  }\n\n  function draw(ctx){\n    for (const p of platforms){\n      const w  = p.lenTiles * tileW * 0.95;\n      const h  = tileH * 0.7;\n      const vx = p.x + (tileW * 0.025);\n      const vy = (p.row * tileH) + ((tileH - h) / 2);\n\n      const bodyHidden = isBodySubmerged(p); // crocs keep head up even if body down\n      const warn = aboutToDive(p);\n      const blinkOn = warn ? (Math.floor(((p.blink || 0) * 1000) / 150) % 2 === 0) : false;\n\n      if (p.type === 'log'){\n        if (!bodyHidden){\n          ctx.fillStyle = '#b07a4a';\n          roundRect(ctx, vx, vy, w, h, 10); ctx.fill();\n          ctx.fillStyle = '#7a5432';\n          ctx.fillRect(vx+6, vy+h*0.25, w-12, 3);\n          ctx.fillRect(vx+6, vy+h*0.55, w-12, 3);\n        }\n      }\n      else if (p.type === 'turtle'){\n        if (!bodyHidden){\n          const segments = p.lenTiles * 2;\n          for (let i=0;i<segments;i++){\n            const cx = vx + (i+0.5) * (w/segments);\n            const cy = vy + h*0.5;\n            ctx.beginPath();\n            ctx.fillStyle = '#2aa66a';\n            ctx.arc(cx, cy, Math.min(h*0.35, tileW*0.32), 0, Math.PI*2);\n            ctx.fill();\n            ctx.fillStyle = '#14593d';\n            ctx.fillRect(cx-6, cy-2, 12, 4);\n          }\n        }\n      }\n      else if (p.type === 'croc'){\n        // --- Croc body (hidden when submerged) ---\n        if (!bodyHidden){\n          ctx.fillStyle = '#1c7a5a';\n          roundRect(ctx, vx, vy + h*0.12, w, h*0.76, 10); ctx.fill();\n          // back scutes\n          ctx.fillStyle = '#125942';\n          for (let i=0;i<Math.max(2, Math.floor(p.lenTiles*2)); i++){\n            const sx = vx + (i+0.5) * (w/Math.max(2, Math.floor(p.lenTiles*2)));\n            ctx.fillRect(sx-4, vy+h*0.12, 8, 6);\n          }\n        }\n\n        // --- Croc head (always visible) ---\n        const g = computeCrocGeom(p); // cache geometry\n        ctx.save();\n        ctx.fillStyle = '#239c74';\n        roundRect(ctx, g.headStartX, g.hy, g.headLen, g.headH, 10); ctx.fill();\n\n        // snout/mouth (hazard zone)\n        ctx.fillStyle = '#d94b4b';\n        const mx0 = (p.dir === 1 ? g.tipX - g.mouthLen : g.headStartX);\n        const mw  = g.mouthLen;\n        ctx.fillRect(Math.min(mx0, mx0+mw), g.hy + g.headH*0.25, Math.abs(mw), g.headH*0.18);\n\n        // eye\n        ctx.fillStyle = '#0a0e14';\n        const eyeX = (p.dir === 1) ? (g.headStartX + g.headLen*0.75) : (g.headStartX + g.headLen*0.25);\n        ctx.beginPath(); ctx.arc(eyeX, g.hy + g.headH*0.28, 3, 0, Math.PI*2); ctx.fill();\n\n        // warning ring on head near dive\n        if (warn && blinkOn){\n          ctx.globalAlpha = 0.9;\n          ctx.lineWidth = 3;\n          ctx.strokeStyle = '#ffd166';\n          ctx.beginPath();\n          roundRect(ctx, g.headStartX, g.hy, g.headLen, g.headH, 10);\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n\n      // Passenger sprite (only on logs/turtles, and only when body visible)\n      if (p.hasPassenger && (p.type === 'log' || p.type === 'turtle') && !bodyHidden){\n        const wpx = p.lenTiles * tileW * 0.95;\n        const hpx = tileH * 0.7;\n        const pvx = p.x + (tileW * 0.025);\n        const pvy = (p.row * tileH) + ((tileH - hpx) / 2);\n        drawPassenger(ctx, pvx + wpx/2, pvy + hpx*0.42, Math.min(hpx*0.35, tileW*0.30));\n      }\n    }\n  }\n\n  // Croc mouth hazard: true if player's tile overlaps a croc's mouth zone\n  function hazardAt(row, col){\n    const pxLeft = offsetX + col*tileW;\n    const pxRight = pxLeft + tileW - 1;\n\n    for (const p of platforms){\n      if (p.row !== row) continue;\n      if (p.type !== 'croc') continue;\n\n      const g = computeCrocGeom(p);\n      const mouthStart = (p.dir === 1 ? g.tipX - g.mouthLen : g.headStartX);\n      const mouthEnd   = (p.dir === 1 ? g.tipX : g.headStartX + g.mouthLen);\n\n      if (pxRight >= Math.min(mouthStart, mouthEnd) && pxLeft <= Math.max(mouthStart, mouthEnd)){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Carry speed if standing on a rideable surface (null => drown)\n  function carrySpeed(row, col){\n    const pxLeft = offsetX + col*tileW;\n    const pxRight = pxLeft + tileW - 1;\n\n    for (const p of platforms){\n      if (p.row !== row) continue;\n\n      if (p.type === 'croc'){\n        const g = computeCrocGeom(p);\n\n        // Body ride when visible\n        if (!isBodySubmerged(p)){\n          const bodyStart = p.x;\n          const bodyEnd   = p.x + p.lenTiles*tileW;\n          if (pxRight >= bodyStart && pxLeft <= bodyEnd) return p.dir * p.speed;\n        }\n\n        // Head ride allowed, but not the mouth zone (caller may also check hazardAt)\n        const headSafeStart = (p.dir === 1 ? g.tipX - g.headLen : g.headStartX + g.mouthLen);\n        const headSafeEnd   = (p.dir === 1 ? g.tipX - g.mouthLen : g.headStartX + g.headLen);\n        if (pxRight >= Math.min(headSafeStart, headSafeEnd) && pxLeft <= Math.max(headSafeStart, headSafeEnd)){\n          return p.dir * p.speed;\n        }\n        continue;\n      }\n\n      // Logs/turtles standard rules\n      if (isBodySubmerged(p)) continue; // turtles down = not rideable\n      const start = p.x;\n      const end   = p.x + p.lenTiles*tileW;\n      if (pxRight >= start && pxLeft <= end){\n        return p.dir * p.speed;\n      }\n    }\n    return null;\n  }\n\n  // Attempt to pick up passenger on current platform (returns true on pickup)\n  function tryPickup(row, col){\n    const pxLeft = offsetX + col*tileW;\n    const pxRight = pxLeft + tileW - 1;\n    for (const p of platforms){\n      if (!p.hasPassenger) continue;\n      if (p.row !== row) continue;\n      if (isBodySubmerged(p)) continue;\n      const start = p.x;\n      const end   = p.x + p.lenTiles*tileW;\n      if (pxRight >= start && pxLeft <= end){\n        p.hasPassenger = false;\n        passengerActive = false;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return { configure, update, draw, carrySpeed, hazardAt, tryPickup };\n\n  // ---------- Helpers ----------\n  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }\n\n  // Prevent head-to-tail coupling in a lane\n  function canSpawnInLane(row, dir, lenTiles, minGapTiles = 1){\n    const gapPx = minGapTiles * tileW;\n\n    // New platform's leading edge (edge entering screen) at spawn time (just off-screen)\n    const leadingEdge  = (dir === 1) ? (offsetX - tileW) : (offsetX + boardW + tileW);\n\n    // Find nearest existing platform in this row, same dir, near spawn edge\n    let nearestDist = Infinity;\n    for (const p of platforms){\n      if (p.row !== row || p.dir !== dir) continue;\n      const pLeading = (dir === 1) ? (p.x + p.lenTiles*tileW) : p.x;\n      const isCandidate = (dir === 1) ? (pLeading <= leadingEdge) : (pLeading >= leadingEdge);\n      if (!isCandidate) continue;\n      const dist = Math.abs(leadingEdge - pLeading);\n      if (dist < nearestDist) nearestDist = dist;\n    }\n\n    if (nearestDist === Infinity) return true;  // nothing nearby\n    return nearestDist >= (gapPx + 1);          // enforce minimum gap in px\n  }\n\n  function computeCrocGeom(p){\n    if (p._geom) return p._geom;\n    const w = p.lenTiles * tileW * 0.95;\n    const h = tileH * 0.7;\n    const vx = p.x + (tileW * 0.025);\n    const tipX = vx + w;\n    const tailX = vx;\n    const headLen = Math.min(tileW * 0.9, tileW * 0.85);\n    const mouthLen = headLen * 0.35; // hazard length at snout\n    const headStartX = (p.dir === 1 ? tipX - headLen : tailX);\n    const headH = h * 0.65;\n    const hy = (p.row * tileH) + ((tileH - h) / 2) + (h - headH)/2;\n    p._geom = { vx, w, tipX, tailX, headLen, mouthLen, headStartX, headH, hy };\n    return p._geom;\n  }\n\n  function isBodySubmerged(p){\n    if (!(p.type === 'turtle' || p.type === 'croc')) return false;\n    if (!p.submerge) return false;\n    // DOWN at start of cycle for `down` seconds\n    return p.phase < (p.submerge.down || 2);\n  }\n\n  function aboutToDive(p){\n    if (!(p.type === 'turtle' || p.type === 'croc')) return false;\n    if (!p.submerge) return false;\n    if (isBodySubmerged(p)) return false;\n    const warnWindow = p.submerge.warn ?? 2;\n    return p.phase >= (p.submerge.period - warnWindow);\n  }\n\n  function drawPassenger(ctx, cx, cy, r){\n    ctx.save();\n    ctx.fillStyle = '#ff77aa';\n    ctx.beginPath(); ctx.arc(cx, cy, r*0.75, 0, Math.PI*2); ctx.fill();\n    ctx.fillStyle = '#0a0e14';\n    ctx.beginPath(); ctx.arc(cx-r*0.25, cy-r*0.15, 2.5, 0, Math.PI*2); ctx.fill();\n    ctx.beginPath(); ctx.arc(cx+r*0.25, cy-r*0.15, 2.5, 0, Math.PI*2); ctx.fill();\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r = 8){\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"/app/js/score-submit.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/js/score-submit.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"(() => {\n  const NAME_KEY = \"player_name\";\n  const S = s => String(s||\"\").replace(/\\s+/g,\" \").trim().slice(0,24);\n\n  async function getName(){\n    let n = localStorage.getItem(NAME_KEY);\n    if (n && n.trim()) return S(n);\n    n = S(prompt(\"Enter a name for the leaderboard (max 24 chars):\",\"Player\"));\n    if (!n) n = \"Player\";\n    localStorage.setItem(NAME_KEY, n);\n    return n;\n  }\n\n  async function submitScore(game, score){\n    try{\n      const player = await getName();\n      const r = await fetch(\"/api/scores\", {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ game, player, score: Number(score) }),\n        cache: \"no-store\",\n        keepalive: true\n      });\n      if (!r.ok) console.warn(\"Score submit failed:\", await r.text());\n\n      const bestKey = {breakout:\"breakout_best\",\"space-shooter\":\"space_shooter_best\",\"highway-hopper\":\"highway_hopper_best\"}[game];\n      if (bestKey) {\n        const prev = Number(localStorage.getItem(bestKey) || 0);\n        if (score > prev) localStorage.setItem(bestKey, String(score));\n      }\n\n      window.dispatchEvent(new CustomEvent(\"score-posted\", { detail:{ game, score, player }}));\n    } catch (e) {\n      console.error(\"Submit error\", e);\n    }\n  }\n\n  window.submitScore = submitScore;\n})();\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"/app/js/score.submit.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/js/score.submit.js` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"(() => {\n  const NAME_KEY = \"player_name\";\n  function sanitizeName(s) {\n    return String(s || \"\").replace(/\\s+/g, \" \").trim().slice(0, 24);\n  }\n  async function getPlayerName() {\n    let name = localStorage.getItem(NAME_KEY);\n    if (name && name.trim()) return sanitizeName(name);\n    name = sanitizeName(prompt(\"Enter a name for the leaderboard (max 24 chars):\", \"Player\"));\n    if (!name) name = \"Player\";\n    localStorage.setItem(NAME_KEY, name);\n    return name;\n  }\n  async function submitScore(game, score) {\n    try {\n      const player = await getPlayerName();\n      const res = await fetch(\"/api/scores\", {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ game, player, score: Number(score) }),\n        cache: \"no-store\",\n        keepalive: true,\n      });\n      if (!res.ok) {\n        console.warn(\"Score submit failed:\", await res.text());\n        return false;\n      }\n      const bestKeys = {\n        \"breakout\": \"breakout_best\",\n        \"space-shooter\":\"space_shooter_best\",\n        \"highway-hopper\": \"highway_hopper_best\",\n      };\n      const k = bestKeys[game];\n      if (k) {\n        const prev = Number(localStorage.getItem(k) || 0);\n        if (score > prev) localStorage.setItem(k, String(score));\n      }\n      window.dispatchEvent(new CustomEvent(\"score-posted\", { detail: { game, score, player } }));\n      return true;\n    } catch (e) {\n      console.error(\"Submit error\", e);\n      return false;\n    }\n  }\n  window.submitScore = submitScore;\n})();\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/block-spacing","replacedBy":["@stylistic/ts/block-spacing"]},{"ruleId":"@typescript-eslint/comma-spacing","replacedBy":["@stylistic/ts/comma-spacing"]},{"ruleId":"@typescript-eslint/brace-style","replacedBy":["@stylistic/ts/brace-style"]},{"ruleId":"@typescript-eslint/func-call-spacing","replacedBy":["@stylistic/ts/func-call-spacing"]},{"ruleId":"@typescript-eslint/indent","replacedBy":["@stylistic/ts/indent"]},{"ruleId":"@typescript-eslint/key-spacing","replacedBy":["@stylistic/ts/key-spacing"]},{"ruleId":"@typescript-eslint/keyword-spacing","replacedBy":["@stylistic/ts/keyword-spacing"]},{"ruleId":"@typescript-eslint/lines-between-class-members","replacedBy":["@stylistic/ts/lines-between-class-members"]},{"ruleId":"@typescript-eslint/no-extra-parens","replacedBy":["@stylistic/ts/no-extra-parens"]},{"ruleId":"@typescript-eslint/object-curly-spacing","replacedBy":["@stylistic/ts/object-curly-spacing"]},{"ruleId":"@typescript-eslint/quotes","replacedBy":["@stylistic/ts/quotes"]},{"ruleId":"@typescript-eslint/semi","replacedBy":["@stylistic/ts/semi"]},{"ruleId":"@typescript-eslint/space-before-blocks","replacedBy":["@stylistic/ts/space-before-blocks"]},{"ruleId":"@typescript-eslint/space-before-function-paren","replacedBy":["@stylistic/ts/space-before-function-paren"]},{"ruleId":"@typescript-eslint/space-infix-ops","replacedBy":["@stylistic/ts/space-infix-ops"]},{"ruleId":"@typescript-eslint/comma-dangle","replacedBy":["@stylistic/ts/comma-dangle"]},{"ruleId":"@typescript-eslint/member-delimiter-style","replacedBy":["@stylistic/ts/member-delimiter-style"]},{"ruleId":"@typescript-eslint/type-annotation-spacing","replacedBy":["@stylistic/ts/type-annotation-spacing"]},{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]}]
